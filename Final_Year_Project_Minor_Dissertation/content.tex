%!TEX root = project.tex

\chapter*{About this project}
\paragraph{Abstract}
This project was developed as my final year project in level 8, B.Sc. (Hons.) in Software Development in GMIT. The purpose of this project was to develop a cross-platform mobile application Using Ionic and the MEAN stack of technologies (MongoDB, Express.js, Angualr.js and Node.js). The application is a Job Advertising app which allows users to create an add for a job they want to get done and the user can also view all other adds created by other users. The users can also message each other through the application.The app consists of a 3-tier architecture, a front-end, back-end and middle tier. The front end consists of our ionic application, the middle tier consists of the node server which contains our API and builds our express app. The backend is our MongoDB database for storing jobs. Ionic handles all of the User Interface and allows the app to be cross platform. The node server acts as a bridge between the database and the app, it’s hosted online using Heroku so the mobile application can access the API as Mobile devices cannot run the node server we have created. Our database is connected to a mlab deployment which is also connected to our Heroku deployment. This all brings the app together with our frontend connected to our hosted node middle tier so it can access the data from the database by consuming the API. Our API is a RESTful API which sends JSON data back and forth between the database and the server and also back and forth between the Mobile application and the server. 

\paragraph{Authors}
This project was developed by Kieran O'Halloran in order to achieve a level 8 B.Sc. (Hons.) in Software Development.

\chapter{Introduction}
This is a dissertation for a final year project which was developed to achieve a B.Sc. (Hons.) in Software Development. This project was designed and created by one student. The idea for the application was to create a cross platform app which would allow users to create advertisments for jobs they needed someone else to do for them. It also allows users to communicate with each other to arrange details for the job to be done such as, a time that suited both, and any other private details which the had to share with each other. The app is named "Tradie".
\section {What it’s about}
The premise of this project was to build a hybrid application that used a collection of technologies that worked together. The project originally consisted of Ionic and Firebase but after much discussion with my supervisor and after some more research we came to an agreement that the two technologies together were too simple for a level 8 project and took too much control away from our server side and database logic. With this in mind, More research was carried out on more technologies which would be more of an appropriate standard for a level 8 project. After all the research  the MEAN stack\cite{Mean-Stack} was choosen.

The MEAN stack is a collection of technologies that are all Javascript based which is great for combined development between the technologies. The MEAN stack consists of an Angular.js frontend, A MongoDB backend for our database while Express and Node.js are the remaining technologies which control our server side logic. Along with the MEAN stack setup, Ionic is also used. Ionic is the framework which is used to handle the frontend of the app. Ionic also allows the app to be cross developed for Android and IOS synchronously.

\section{Scope}
The project has a three-tier architecture with 3 unique parts all communicating with each other to form the app. The 3 tiers are as follows:
\subsection{Backend/Database tier}
This is the mongo database which contains all the information on jobs that users can create and delete from the app. This database is also connected to an mLabs connection which in turn is then connected to the Heroku deployment which hosts the Node server with the RESTful API. Together these technologies all form the pieces which allow users to add to and delete job items. In summary, the backend of the app sends information in JSON format to the Node server and anything sent from the frontend to the Node server is also sent back to the database in JSON format.

\subsection{Server side/Node}
This is the middle tier which connects the Ionic app to the Mongo database.  This tier consists of the Node server which contains the RESTful API and tells the app to connect to the database containing the jobs. The REST API allows the app to get JSON data from the server and output it in our UI in the app. This tier is also hosted on Heroku. This allows users on their phone to use this app as Node servers can not be run by a mobile device. Instead, the Ionic app connects to the hosted Node server on our Heroku deployment. 

\subsection{Frontend/ Ionic application}
The front-end of the application is the cross-platform app developed using Ionic. Ionic uses a combination of HTML, SCSS and Typescript to design the UI of the app. The Ionic app gets data from the database by connecting to our Node server which contains the REST API. It also allows users to add data to the server using a UI to input information which is pushed in JSON format to the server and into the database.

\section{Objectives}

The primary object in developing this application was to learn a set of new skills using the MEAN stack to build a cross-platform mobile application. To go about this milestones were set from the beginning:
\begin{itemize}
\item To create our app using Ionic and the MEAN stack by learning the new framework and getting to grips with Typescript. Learning how to create our MongoDB database and connect it to mLabs and then connecting the Ionic app to the database using node. By the end of this project, the aim was to be very familiar with these technologies and how they work.
\item Users to be able to access the app securely with authentication and be able to login with a username and password.
\item Users to be able to post jobs or just general work they needed someone to do. Write them to the app and also be able to delete them again.
\item Users to be able to see immediately any newly added jobs to the app by other users. If users refresh the Job page in the app and someone has added a new job since the last refresh, the new job should appear on their device. 
\item Users to be able to message each other to arrange details for carrying out the job
\end{itemize}


\section{Documentation}
Up until now, this document has given a brief description of what this project is, how it was developed, where the idea came from, the goals for the project and the scope of the project. This project will be discussed in even more detail under the following headings in this document. 

\textbf {Methodology} - This section contains how project was implemented in terms of both development and research and will also give the opinion on how everything was approached at a proper level for a level 8 project. The project planning will be discussed in terms of which project methodology was used, how often meetings took place and what the meetings consisted of, how the work was divided into different sections with different deadlines to make this application achievable and the feedback received from the supervisor.


\textbf {Technology Review} - This part of the documentation documents the outcome of the research into the technologies that were used in the project and how they were implemented to achieve the objectives described in the introduction. Each technology used for the app will be described in detail in both what they are and exactly how they were used.

\textbf {System Design} - This section will describe the architecture of the project. It will describe how each technology works together to form this application. It will have diagrams to help visualise the architecture of the project and will contain screenshots of the application.

\textbf {System Evaluation} - This is where the project will be evaluated by comparing the final outcome of the app to the objects initially set out. Difficulties and limitations met in the development process of the app will also be discussed in this section.

\textbf {Conclusion} - This will be a summary of the entire finished project. It will discuss the goals of the project that were set at the beginning and how well they were achieved throughout the development process. It will discuss what was learned and the experiences in developing this application. It will mention what was done right during development and what would be changed if given the chance. Overall it will nicely wrap up this documentation and add some final piece of insight on the overall project experience.

\chapter{Methodology}
\section{Initial planning and research}
Before this application was developed there was a lot of research conducted on the different technologies that would be involved in the project. Ionic was chosen as the frontend technology for this application. Some time was spent researching the features and technologies like Typescript. After completing research of the framework it was felt Ionic was the right choice and was at the right level of complexity to be worthy of a level 8 project.
With the frontend technology chosen research then continued for the backend technology. It was clear the backend would have to have a database for the jobs and in the future this database would have to be hosted online. This resulted in choosing Firebase. It would have allowed the application to store information in an online database, Authenticate users with their firebase authentication service and host the app online for use in a web browser.
In the end, the original approach planning proved to be ineffective and not well thought out. It was advised by the supervisor that the application should be build using a three tier architecture. This set the development of the project back a bit  as the development had already started and quite a bit of work had been done at this stage. More research had to be done on some new technologies and see how they could work with the application. The methods of project planning are discussed below.

\section{Project planning and meetings}
All planning of this project was done in weekly manner, since this Final Year Project was developed by a single student, there was not any meetings on the team project discussion The first thing to do was sit down and brainstorm what the app was going to be and how it was going to be achieved. When the idea had been picked the next step was to set out some objectives to be met by the next meeting and begin researching the technologies.

There was then had weekly meeting with the supervisor Dr. John Healy to whom all research and findings were presented and discussed how to go about development in a structured and organised fashion. John was very helpful when it came to project planning and he advised us greatly on how to approach development in different stages. He also helped advised that the original project idea might not have been to the standards of a level 8 project and he also advised to conduct research into the MEAN stack which is the group of technologies used for development.
Each of these technologies were new to me so heavy research had to be completed in order for this project to be developed properly. With all the technologies researched and the application outline set, development on the app started. The app was split in two parts with both the ionic frontend and the MongoDB backend. It was decided to split development of these into different parts which would be carried out at different stages of the development. 
Weekly meeting with John continued and each week there would be an objective set and the goal would be to have it completed by the next meeting. If the objectives were not met any problems would be discussed and a solution would be worked out. 

\section{Development Tools}
\subsection{The hardware environment}
\begin{itemize}
\item Laptop configuration: \\ \\ CPU: 1.6 GHz Intel Core i5. \\ RAM: 8 GB 1600 MHz DDR3. \\ Graphic: Intel HD Graphics 6000 1536 MB. \\ Operation System: OS X EI Capitan.
\end{itemize}

\subsection{Software Environment}
\begin{itemize}
\item Development Tool: Visual Studio Code (version 1.22.1).
\item Browser: Google Chrome.
\item Development Enviroment: Node.js.
\item Database: Firebase/ MongoDB
\end{itemize}

\subsection{Visual Studio Code Editor}
\begin{itemize}
\item Download Link: https://code.visualstudio.com/ \\ \\ Visual Studio Code is a source code editor developed by Microsoft for Windows, Linux and macOS. It includes support for debugging, embedded Git control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also customizable, so users can change the editor's theme, keyboard shortcuts, and preferences. It is free and open-source. \\ Visual Studio Code is based on Electron, a framework which is used to deploy Node.js applications for the desktop running on the Blink layout engine. Although it uses the Electron framework, the software does not use Atom and instead employs the same editor component (codenamed "Monaco") used in Visual Studio Team Services (formerly called Visual Studio Online). \\ In the Stack Overflow 2018 Developer Survey, Visual Studio code was ranked the most popular developer environment tool, with 34.9\% of 75398 respondents claiming to use it.\cite{VSC}
\end{itemize}

\section{Platform Brief}
\subsection{GitHub Profile}
GitHub (originally named Logical Awesome LLC) is a Web-based hosting service that uses git for version control. It is mainly used for computer code. It provides all of Git's distributed version control and source code management (SCM) capabilities and adds its own features. It provides access control and various collaboration features for each project, such as bug tracking, feature requests, task management, and wikis. \\ \\ GitHub Personal Repository and Wiki pages You can edit these pages using the git repository. As a distributed version control system, Git does not have a conceptual main library. Each warehouse copy can be used independently. Any differences between these warehouses can be combined together. \\ \\ GitHub can host a variety of gits and provide a unified web interface. However, providing different service code management websites such as Source Forge and Google Code, GitHub's unique branch project management is very simple and highly interoperable. If you want to contribute code to your project it is an easy task: first on the project site for the "fork" button, then check the code and add the changes to a separate code base, and finally through the built-in "pull request" mechanism applicable to the project director code.




\chapter{Technology Review}
In this section, the different technologies incorporated in to this project will be discussed.A variety of new technologies have been used to bring this project together. In this section all of these technologies will be explained and the reason for choosing them.

For the backend development, The MEAN stack was used, for front-end development the Ionic Framework was used for cross platform app development so the app could be built for a range of devices. Such as, Android, IOS and Windows Phone. Node.js was then used for the server side aspect of the application, the node.js server was then hosted on Heroku. Firstly, the MEAN stack will be discussed, followed RESTful API, Ionic, firebase and Heroku and then finishing off with GitHub. 

\section{MEAN-Stack}
What is the MEAN stack? A straight to the point explanation would be that the MEAN-Stack is a free and open-source JavaScript software stack for building dynamic web sites and web applications. Mean Stack is a combination of four popular and highly efficient Javascript libraries, namely MongoDB, Express.js, Angular JS and Node.js. (Shortened down to M for Mongo, E for Express, A for Angular and N for Node). 

Mongo DB can be used to store documents in the JSON format, these JSON queries are then handled by Express JS and Node.js on the server side. Angular JS on the frontend is then fed these JSON documents. With the same language on both the client side and the server side. These two technologies work extremely well together and integration between these two environments is seamless and very subtle.\cite{Mean-Stack}

Because all components of MEAN stack support programs written in JavaScript, MEAN applications can be written in one language for both server-side and client-side execution environments. In order to completely understand the reasons why MEAN stack is so widely used. Each of its components will be explained in detail below. 



\subsection{MongoDB}
The MEAN stack comes with a NoSql database technology called MongoDB.
It is important that we understand what a NoSQL database is before going into further detail on MongoDB. NoSQL stands for (Not only Sequential Query Language). It is a database that provides a mechanism for storage and retrieval of data which is modelled by means other than the tabular relations used in relational databases. 

NoSQL databases have been proven to be the solution to what is
known as Big Data as they follow a schema-less data model. A NoSQL database provides increased scalability and flexibility compared to relational databases. Studies show that in recent years developers and organisation have experienced a sharp rise in the volume of user data and products that have to be stored in databases. 

NoSQL databases started gaining popularity in the 2000’s when companies began investing and researching more into distributed databases \cite{no}.
NoSQL databases are widely used to store and retrieve very large amounts
of data using a key-value format. These types of databases have emerged
as the best choices that suite modern mobile and web development. So now that its clear what NoSql is we are going to talk about MongoDB in more detail.

MongoDB is a schema-free document database written in C++ and developed in an opensource project by the company 10gen Inc \cite{mongoname}. The name mongo is extracted from the word humongous. According to its developers, the main
goal of MongoDB is to close the gap between the fast and highly scalable key-value-stores and feature-rich traditional RDBMSs.
It provides high availability , high performance, and automatic scaling
and allows data insertion without a predefined schema. 

MongoDB is one of several database types to arise in the mid-2000s under the NoSQL banner. Instead of using tables and rows as in relational databases, MongoDB is built on an architecture of collections and documents. Documents comprise sets of key-value pairs and are the basic unit of data in MongoDB. Collections contain sets of documents and function as the equivalent of relational database tables. 
A record in MongoDB is composed of field and value pairs and are similar to
JSON objects. The value of field may consists of arrays, and array of documents
or other documents.

MongoDB maintains data consistency in the
sense that one write operation to the data in the database allow subsequent
read operations. They use a locking mechanism that contributes to increased
execution time as the number of update operation increases. [8] [10].

MongoDB supports dynamic schema design, allowing the document a collection to have different fields and structures. The database uses a document storage and data interchange format called BSON, which provides a binary representation of JSON-like documents. MongoDB also uses Automatic sharding wich enables data in a collection to be distributed across multiple systems for horizontal scalability as data volumes increase.\cite{MongoDB}.


\subsection{How Mongo Works In the Application}
In the application, Mongo was used to store information from the jobs section. People are able to add a job and post so other users could then also see that job. An example of how endpoints in the node server are set up is shown here:

\begin{minted}{javascript}
 app.post('/api/jobs', function(req, res)
\end{minted}

Next, A Job provider was created which was a Typescript file that contained three methods getJobs, createJob, and deleteJobs. The getJob function sends a get request to my Heroku server that will then return my job data. The createJob function accepts a job object as a parameter and then posts that to the same endpoint. While my deleteJob function will make a request to the API to delete it. A small extract of my getJobs function is shown below:

\begin{minted}{javascript}
 getJobs(){

if (this.data) {
return Promise.resolve(this.data);
}

return new Promise(resolve => {

this.http.get('https://kierantradie.herokuapp.com/api/jobs')
.map(res => res.json())
.subscribe(data => {
this.data = data;
resolve(this.data);
});
});
}
\end{minted}

Mongoose was used to connect the application to mlabs. Mongoose is a MongoDB Object Document Mapper (ODM) for Node. It provides the user with a simple validation and query API to help you interact with the MongoDB database.

\begin{minted}{javascript}
mongoose.connect('mongodb://heroku_lz2bt2wt:kabs1g4ubvtolmbjkvold9inkd@ds227185.mlab.com:27185/heroku_lz2bt2wt',{ useNewUrlParser: true }, function (error) {
    if (error) console.error(error);
    else console.log('Mongo Connected');
});
\end{minted}


\subsection{Express}
Express is another component of MEAN Stack. Express is a nodejs asynchronous based web framework. Express.js builds on the underlying capability of Node, by providing a web application server framework. Express.js is a Node.js web application server framework, designed for building single-page, multi-page and cross platform hybrid web applications and it gives Node.js a more realistic website structure that is not present when using Node by itself. For the application express will allow routes to be created for the REST API that will be created.\cite{expressjs}
\subsection{Node.js}

Node.js is a Javascript runtime built on Chrome’s V8 JavaScript Engine.
Node.js uses an event driven, non-blocking I/O model that makes it lightweight
and efficient web server environment, ideal for constructing a web-service
API’s. Node.js package ecosystem, “npm”, is the largest ecosystem of open
source libraries in the world. For the application node will be the server which will sit between the frontend of the application and the MongoDB database.\cite{nodejs}

\subsection{AngularJs}
The final component making up the mean stack is Angularjs. Defined in Angulars official documentation\cite{angularjs} - AngularJS is a structural framework for dynamic
web apps. Angular allows the user to use HTML as their front-end language and lets you extend HTML’s syntax to express an application’s component clearly. Angular also has a data binding and dependency injection which eliminates much
of the code you currently have to write. This all happens within the
browser, making it a perfect partner for any server technology.

AngularJS simplifies application development by presenting a higher level of abstraction to the developer. Like most types of abstraction, it comes at a cost of flexibility. In other words, not every app is a good fit for AngularJS. AngularJS was built with the CRUD application in mind and this was another reason why I thought this technology would be a good fit for my application as I wanted to be able to add and delete data to a database. \cite{angularjsa}
 
There are a number of reasons why angular js is so popular and some of which include how Angularjs structures the source code by following
the Model View Controller. The second reason is  Angularjs ability to do two-way data binding. It decreases the amount of code
that is written to keep the model and view in agreement.  Angularjs
models are old java object (POJO), therefore it is quite simple to change or
append properties without any major complications. Finally, and probably the most important
feature that Angular js has to offer is dependency injection. Dependency injection
is a software design pattern that deals with how components get hold of
their dependencies. The angular injector subsystem is in charge of creating components, resolving their dependencies and providing them to other
components as requested \cite{angularjsfeat}.

After speaking in some detail about each component of the mean stack you should have a clear understanding of this technology and how it works and benefits applications.  


\section{RESTful API}
A RESTful API is an application program interface (API) that uses the HTTP requests GET, POST, PUT, and DELETE data. A RESTful API, which is also referred to as a RESTful web service is based on representational state transfer (REST) technology\cite{Restapi}. 

A RESTful web service is based on representational state transfer (REST) technology. It is an API that communicates with HTTP requests to GET, PUT, POST and DELETE data and then links to the four fundamental database operations - CREATE, READ, UPDATE, DELETE. An API for an application is basically code that allows two software programs to communicate with each another. In case of this application the API is created in the node server file and this then links to the database where HTTP requests are applied. 

\subsection {How RESTful API's work}

The API basically takes different parts of a transaction to make a number of small modules. These modules then target a specific underlying part of the transaction. As a result, developers are provided with a lot of flexibility.

The RESTful API uses GET for read and idempotent requests to retrieve a resource,  POST for write requests which create a resource, PUT to change the state of or update a resource and DELETE to remove it. All calls are presumed to be stateless which means nothing can be retained by the RESTful service between executions. As a result,  REST is suited to cloud applications because stateless components can be freely redeployed if something fails. \cite{RESTful}

The reason for this is that requests can be directed to an instance of a component and therefore there is nothing kept that needs to be remembered by the next transaction.

For these reasons REST is largely preferred for web/mobile use. The RESTful model can also be extremely helpful in the cloud as using APIs to bind services is as simple as controlling how the URL is decoded. 

\section{Ionic}
Ionic is a complete open-source SDK for hybrid mobile app development. It is built on Angular. Ionic provides tools and services for developing hybrid mobile apps using Web technologies like CSS, HTML5, and Sass. Apps can be built with these Web technologies and then distributed through native app stores to be installed on devices by using Cordova.
\item Services and features: Ionic provides all the functionality which can be found in native mobile development SDKs. Users can build their apps, customize them for Android or iOS, and deploy through Cordova. Ionic includes mobile components, typography, interactive paradigms, and an extensible base theme. \\ Besides the SDK, Ionic also provides services that developers can use to enable features, such as push notifications, A/B testing, analytics, code deploys, and automated builds. \\ Ionic also provides a powerful command-line interface (CLI), so developers can get started with creating a project with a simple command. The CLI also allows developers to add Cordova plugins and additional front-end packages \cite{7}, enable push notifications, generate app Icons and Splash screens, and build native binaries. \\
\item Supported platforms: Ionic is focused on building for modern Web standards and for modern mobile devices. For Android, Ionic supports Android 4.1 and up. For iOS, Ionic supports iOS 7 and up. Ionic 2 supports the Universal Windows Platform for building Windows 10 apps. Ionic Framework, powered by Angular.js, supports BlackBerry 10 apps.
\item Installation: Ionic is an npm module and requires Node.js.
\begin{itemize}
\\ \item Install Ionic Code: npm install -g ionic \\ First, install Node.js. Then, install the latest Ionic command-line tools in your terminal. Follow the Android and iOS platform guides to install required tools for development. \\ 
\item Start an App: ionic start myApp tabs
\item Run your App: cd myApp \\ ionic serve \\ Most applications can be built in browsers using ion services. When you are ready to deploy the application to a real device, you can review the deployment guide.
\end{itemize}




\subsection {Typescript}
As previously mentioned one of the main difference between Ionic 1 and 2 is the fact that Ionic 2 uses Typescript instead of javascript. Microsoft created TypeScript with its first public release in October 2012 but Typescript has only become more popular in web development since angular and ionic added it to their 2.0 frameworks. So to get a better grasp of Typescript we are going to talk about it here in more detail.
Basically, TypeScript is a superset of JavaScript that compiles into Java, which means it behaves identical to JavaScript but with some extra features added in. So you don't run TS on your web server, ultimately it’s all JavaScript. TypeScript also allows developers access to powerful tools for writing modern JavaScript.\cite{typescript} \cite{typescript2}



\section{Firebase}

For the login page the user Authentication needed to be handled. To do this Firebase Authentication was used. 

Firebase Authentication provides backend services, SDKs, and ready to use UI libraries to authenticate users of your application. It supports authentication using passwords, popular federated identity providers like Google, Facebook and Twitter.\cite{firebaseauth}

Firebase Authentication integrates with other Firebase services, and it competes with industry standards like OAuth 2.0 and OpenID Connect, so it can be easily integrated with a custom backend. 

A user is able to sign in to a Firebase app by either using FirebaseUI as a complete drop-in auth solution or by using the Firebase Authentication SDK to manually integrate one more of the  sign-in methods into the application. For my application I used the firebase SDK. By doing this we were able to choose which sign in methods we wanted to add to our application. I decided to use just email and password authentication. 
Firebase Authentication also handles sending password reset emails. The firebase SDK also comes with a reset password feature which sends the user an email with a link to reset there password. This is a good security measure as the user will need to have access to their personal email account before they can reset their password.\cite{firebase}
\subsection{Realtime Database}
The Firebase Realtime Database is a cloud-hosted database. Data is stored as JSON and synchronized in realtime to every connected client. As this is a cross-platform app with iOS, Android, and Windows, all of the clients share one Realtime Database instance and automatically receive updates with the newest data.\cite{realtime}

\section{Heroku}
In this application, it needed somewhere to be deployed to. After a lot of research and experimentation, it was determined that Heroku\cite{heroku} would be the best solution. Heroku hosts the Node server with the RESTful API. The Heroku deployment is then connected to mLab which is a fully managed cloud database service that hosts MongoDB databases and connects them to services like Heroku \cite{mlab}. This then allowed the application to run with out any intervention. 

This was the most difficult part of the project to get working as there was a lot of trouble getting the database to properly connect with Heroku but after extensive research and a lot of testing it was discovered that the node.js server needed to be pointed to the build of the application and then add the URL of the Heroku instance.

\section{GitHub}
GitHub is a web-based collaboration platform for software developers, delivered through a software-as-a-service (SaaS) business model which allows you to host and review code along with managing projects. Github first launched in 2008 and was founded on Git which is an open source code management system created by Linus Torvalds to make software builds faster.\cite{github}

Git works by storing source code from projects and tracking all changes made to that code to a repository. Repositories can be made either public or private so developers can share their code. It is a great tool for developers when collaborating projects as it provides users tools for managing changes from different developers. I found this to be greatly beneficial in my development.

GitHub works by using git commands to push projects up to its website \cite{gitcommands}. The process behind this is straight forward. First the user needs to use git bash to navigate to the folder they want to upload. This folder then needs to be initialized by using the command:
\begin{minted}{javascript}
$ git init
\end{minted}
This command creates an empty Git repository which has a .git directory with subdirectories for objects, refs/heads, refs/tags, and template files. A HEAD file is also created and this file references the HEAD of the master branch.
The next command you have to use is:
\begin{minted}{javascript}
$ git add .
\end{minted}

This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. 

Once the files are added you need to run:

\begin{minted}{javascript}
$ git commit -m""
\end{minted}
This stores the current contents of the index in a new commit along with a log message from the user describing the changes. And then finally run:
\begin{minted}{javascript}
$ git push origin master
\end{minted}
to push all the files to the master branch of your repository.

Other features that GitHub has to offer are its ability to fork, pull and merge from someone's repository. A fork is essentially a copy of a repository that allows developers to make modifications without affecting the original code.  If the developer would like to share the modifications, they can send a pull request to the owner of the repository. The owner can then decide after reviewing the modifications if they would like to pull the modifications into the repository. They then have the option to accept the modifications and merge them with the original repository.\cite{githubop}

Another feature of Github that was very helpful is the commit history. Everytime you make a change to your code and push it up to Github you are creating a commit. A commit is Githubs way of tracking the changes you have made to the project since your last commit. It was useful because it was easy to see what was pushed up and exactly what was added or removed. You are also able to download the project from a commit at any point, so for example you added features to the project that you no longer want you can revert back to any point in your commit history. This feature was used on a few occasions as often problems were encountered after doing some work on the project which resulted in issues and errors and It saved me a lot of time as a result.


\chapter{System Design}
 \section{Architecture}

The architecture of this project is divided into three different tiers of technologies. The frontend tier containing the Ionic application, the middle tier containing our node server which contains the endpoints for the REST API. The middle tier also consists of a Heroku deployment which serves the node server online and AngularFire which is used for connecting the app to Firebase databases for user authentication. The backend is the data tier which contains the MongoDB database which stores all of the jobs created by the users. This database is in turn connected to an mLabs database which links to the Heroku deployment. The backend also contains a firebase database which stores all the User authentication details for the Login system. A diagram of the architecture is shown below:


\begin{center}    
	\includegraphics[width=15cm, height=6.8cm]{img/system.png}
\end{center}

\section{Front end}
In the image above to the left, you can see the technologies that consist of the front end. Ionic 2 and  Angular 2 were used to create a cross-platform application that would run on both Android and IOS. As you can see in the diagram the Ionic 2 application is connected to the Heroku deployment which hosts the REST API. The app sends a GET request to get the JSON data from the API to display the jobs inside the app. The app can also send a POST request to the API when a new job has been created on the app and also a DELETE request when a job has been deleted from the app. When the application development was completed the Ionic CLI was user to build the application .apk for both platforms using the following command:

\begin{minted}{javascript}
$ >cordova build.
\end{minted}
Since the Ionic app is the frontend, it iof course also contains the User Interface for the app which will be discussed in further detail in the following sections.
\section{Middle Tier}
In the diagram above in the middle tier, you can see most of our technologies reside in this tier. This is the main logical side of our application and it is a very important part in bringing all of the technologies together to complete the app.
\subsection{ Node server}
The most imported part of this entire tier is the Node server. With node, the file called server.js was created which defines our REST API endpoints. Any modules necessary for the application were also defined here. The node server connects to the mLabs deployment and translates the data into JSON format so it can be sent back and forth between the node server and the database and also so it can be sent back and forth from the node server to the Ionic application.
\textbf {Module definition}
\begin{minted}{javascript}
var express = require('express');
var app = express();
var morgan = require('morgan');
var bodyParser = require('body-parser');
var methodOverride = require('method-override');
var cors = require('cors');
var mongoose = require('mongoose'),
\end{minted}
\textbf{Api Endpoints}
\begin{minted}{javascript}
app.get('/api/jobs', function(req, res) {...}
app.post('/api/jobs', function(req, res) {...}
app.delete('/api/jobs/:job_id', function(req, res){...}
\end{minted}
\textbf {Connection to our mlab}
\begin{minted}{javascript}
mongoose.connect('mongodb://heroku_lz2bt2wt:kabs1g4ubvtolmbjkvold9inkd@ds227185.mlab.com:27185/heroku_lz2bt2wt',{ useNewUrlParser: true }, function (error) {
    if (error) console.error(error);
    else console.log('Mongo Connected');
\end{minted}
\subsection{Express}
Express is used in the application in conjunction with the node server in order to build the server as a node application. This allows the server to run and handle all API requests and gather the JSON data and apply it to the app. Express also allows the Heroku deployment to run the application online for use in a browser by finding the latest build of the project in the www directory and pushing it to the Heroku deployment. By doing this the API for the jobs is also pushed to Heroku for the Ionic App to connect to.


\subsection{Heroku and mLabs (Cloud Hosting)}
In order for the application to access the node server, it needed to be able to host the server online. Mobile devices are not able to run Node applications, therefore, the only to connect to the server is to get it hosted online, otherwise, the jobs on the app would not appear. Heroku and mLabs combined, worked well together when it came to solving this problem. The first step was to initialized a git repository inside the app and pushed the Node/Express app to the server. Then connected the local database to an mLabs deployment which allowed for the hosted API to now interact with the online database. The job data can be viewed at the following URL to verify our API has been hosted. 
 \url{ https://kierantradie.herokuapp.com/api/jobs}
 
Using the above link it was possible to connect the Ionic app to the now online Node server. This means the API can now be used by the application on mobile devices. An example of how they are connected is shown below: 
 
 
 \begin{minted}{javascript}
this.http.get('https://kierantradie.herokuapp.com/api/jobs')
this.http.post('https://kierantradie.herokuapp.com/api/jobs'
, JSON.stringify(review), {headers: headers})
this.http.delete('https://kierantradie.herokuapp.com/api/jobs/'
 + id)
 \end{minted}
\subsection{AngularFire2}
Angularfire 2 is a library created for connecting Firebase 3 to Angular 2. This was used for authentication services. AngularFire2 contains functions and classes which help connect the app to the Firebase database containing all of the users information. Angularfire allowed the creation of functions with firebase so users can sign up to the app, login, or if they have forgotten their password an email will be sent to them so they can reset it.
\section{Back end}
We have two database services in the backend of our application. The firebase database which contains all information of our users who can log in with their email and password or with Facebook. An example is shown below:
\begin{center}    
	\includegraphics[width=10cm, height=5cm]{img/users.png}
\end{center}
The mongodb contained data on the jobs which users can create. This mongodb instance is connected to a mLab deployment in order for our hosted node application to connect to it. Mongoose provides a straight-forward, schema-based solution to model the application data. A job model is used which consists of 
\begin{itemize}
	\item Title
	\item Description
	\item Location
	\item Price
\end{itemize}
The model was designed on the bases of what information the  users would want to input into their jobs. The title is simple, the  description is used for writing comments about the job and the location is the county in which the job will take place and finally the user can give the maximum price they can afford to pay for the job.
The model represented in our code is as follows:
\begin{minted}{javascript}
var Job = mongoose.model('Job', {
    title: String,
    description: String,
    location:String,
    price: Number
});
\end{minted}
This database was then connected to mlabs which uses collections to store its data. Mlabs automatically creates an id number from the mongodb database that it is connected to and it assigns it to the job that is pushed up. The design of the mlabs database is shown below: 
\begin{minted}{javascript}
{
    "_id": {
        "$oid": "5c93ec99ad51ea0017873771"
    },
    "title": "Fireplace",
    "description": "I am looking to install a new fireplace in my sitting room",
    "location": "Mayo",
    "price": 1301,
    "__v": 0
}
\end{minted}

\section{Ionic Application}
With the architecture discussed above we can see how they were used to form our app. In this section the individual pages will be discussed.
\subsection{Login Page}
\begin{center}    
	\includegraphics[width=7cm, height=12cm]{img/login.jpg}
\end{center}
This page allows the user to log into the app using the firebase authentication. The user enters their email and password and presses login. When the login button is pressed the user details are compared to details in the firebase database to see if it’s a valid user. If the information entered is correct the app navigates to the home page. If the information is invalid and an error message is shown and the user cannot navigate to the main page of the app. There is also a signup button which navigates to the signup page, a forgot password button which creates a popup where the user can enter their email address and a reset likn is emailed to them.
\subsection{Create Account Page}
\begin{center}    
	\includegraphics[width=7cm, height=12cm]{img/createaccount.jpg}
\end{center}
The create account page allows users to enter their credentials to register for use of the app. When the email and password are entered they are validated to make sure they are correct. If they are the details are stored in the database and the app navigates back to the login page. If the details aren’t valid the user is told what details need to be changed in order to sign up for the app.
\subsection{Reset Password Popup}
\begin{center}    
	\includegraphics[width=7cm, height=12cm]{img/forgotpassword.jpg}
\end{center}
On the reset password popup the user can enter their email that they used to register to the app and firebase will send them an email that will contain a link for them to reset their password.
\subsection{Jobs Page}
\begin{center}    
	\includegraphics[width=7cm, height=12cm]{img/job.jpg}
\end{center}
\begin{center}    
	\includegraphics[width=7cm, height=12cm]{img/addjob.jpg}
\end{center}

In these pages, the user can view, create and delete jobs. The list of jobs is pulled from the hosted Node server which contains the REST API which sends JSON data to the app which is translated into the list you see above. If the plus symbol at the top of the app is selected the user is navigated to the add job page. Here the user must enter a title for their job, a description, a location and give a maximum price and then press save. Once this is done the app sends JSON data to the node server hosted on Heroku. This information is then used to store the job in the database. Now, this job will be added for every user using the app. If a job is swiped to the left it can be deleted or the user can send the creator of the job a message.
\subsection{Message Page}
\begin{center}    
	\includegraphics[width=7cm, height=12cm]{img/message.jpg}
\end{center}
In this page the users can interact with each other and send private messages back and forth.















\chapter{System Evaluation}
As mentioned in the introduction of this paper the main objective when when development started on this app was to learn a whole new set of skills. Primarily using the MEAN stack to develop a cross platform mobile application. The main objective in terms of functionality of the application was for users to be able to post jobs and save them to the application and also be able to delete them again. This goal was achieved as there is a page on the application that allow users to do exactly that. The next goal was to have a feature where the job page would be hosted online. Again this was achieved  as the mongodb database is connected to Heroku. This meant that all jobs would be saved here and any changes will reflect on application for all users. The login authentication was handled by Firebase Auth the end user app was built in ionic framework which is easily consuming the data from an API and the synchronization is very smooth and is working effectively. 
\section{Testing}
To be sure all parts of the application works correctly tests need to be run on the application. Testing is an important task of any software project, without testing, programmers could easily introduce more bugs to a project. It's extremely important to test each section of a software project before releasing a new version of the application. Creating automated tests for your application is a great way to improve the quality of your code and protect against code breaking.
For testing the application. I ran it many times in the browser and checked that all the implement features worked correctly. I also used the .apk which was created to test the application on an android device and found all the features to work relatively smoothly.

\section{Limitations}
Most software projects come with limitations and this project is no different. The main limitation for this application is the jobs part of the application need a constant internet connection in order to work. I looked at possibly implementing a CouchDB technology however I felt like it wouldn't really solve the problem. Another limitation to the application is that all users can vies the messages that have been stnt on the application.

\chapter{Conclusion}
In Conclusion, it has been extremely interesting and highly rewarding working on this application. There was many problems faced during the development of this project but I felt they were handled  quite well. The first problem was the fact that technologies were changed mid-development. This required some adjustment but was also a great learning experience as I had to adjust quickly to the change. The second major problem I faced was working on deploying the application to Heroku. I was getting errors and lots of them but after a lot of time and research I overcame these errors. Despite these setbacks, I fell I gave it my best effort and I was able to implement all the objectives set out before development started. In the introduction, there were five main objectives set out for this project. They were as follows:
\begin{itemize}
	\item Create an application using Ionic 2 and the MEAN stack.
	\item Have a secure login page for users.
	\item A section where users are able to post jobs they needed someone to do.
	\item A feature where these reviews would then be seen immediately by other users. 
              \item A feature where users could contach each other through the application
\end{itemize}
The first objective was successfully achieved when the MEAN stack was implemented into the Ionic application. The use of MongoDB, Express, Angular and node gave the application a more complex feel when developing, as these technologies are widely used together in industry. These technologies were also brand new for me so it was challenging at first to get to grips on how they all worked together, but to have fully implemented them in this project was very satisfying for me. Another challenge I faced with these technologies was the fact that I originally had planned to use just firebase but after a discussion with my supervisor he advised me to change this as using just firebase wouldn't have been enough for a project at this level. I am glad I listened because I feel that I wouldn't have got a lot out of using just the Firebase technology.

The second objective was also completed, having a secure login page by using firebase authentication. As I had previously done some work with firebase I decided to carry this aspect over as I found it to be very secure. This allowed the storage of usernames and passwords in an online database and also have a function which allowed users to reset their passwords. The reset function was very secure as the user would have to enter their email address and if that email address matches an email address on the firebase database they would then receive an email with a reset password link.

The third objective was to add a page where users could post jobs they needed someone to do for them. This part of the application was achieved by using the mean stack and was one of the harder parts of the project to implement. As mentioned above the technologies were new to me so it was challenging, however, I wanted this project to challenge me as I wouldn't have learned anything from doing a project that was easy and already familiar to me.

The main objective and defiantly the hardest part of the application to implement was having somewhere to store the jobs online. For this, Heroku was used which was difficult to get connected to the application. To go about this the database had to be hoseted on a website called mlab which is then connected to the local MongoDB database. The mlab instance was then connected to Heroku and after a lot of research and trial and error it eventually worked and the applications jobs now update for all users. Getting this part of the project working was probably the most rewarding part as I had not connected a database to Heroku before and I spent a lot of time researching how to do this.

The final objective was allowing the users to contact each other through the application. This was done using the Firebase Realtime database. This was used so the messages would appear instantly. I felt this was a good feature to add to the application as it made it easy for users to discuss further details and arrangements for completing the job.


As a whole, I was extremely happy with how this project turned out. I learned a lot more than I thought I would in terms of the technologies used and how to implement them. I will also take valuable lessons from this experience such as better planning when deciding the technologies that are going to be used. The biggest lesson I will take from this experience is how to work effectively in short spaces of time. Despite the fact I did this project on my own I felt it went very well. I also managed to meet the project deadline. Overall these lessons will stand to me in the working world and this experience has defiantly better prepared me for exactly that.




\chapter{Appendices}
\textbf {GitHub: } \url{https://github.com/123kieran/Year4_Project}

\textbf {Heroku: } \url{https://kierantradie.herokuapp.com/}
